// DO NOT EDIT
// generated by pyang using OpenConfig https://github.com/openconfig/public
//
// Copyright (C) 2014-2019 Nippon Telegraph and Telephone Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by pyang. DO NOT EDIT.

package config

import (
	"fmt"

	"github.com/osrg/gobgp/v3/pkg/packet/bgp"
)

func mapkey(index int, name string) string {
	if name != "" {
		return name
	}
	return fmt.Sprintf("%v", index)
}

// typedef for identity bgp-types:remove-private-as-option.
// set of options for configuring how private AS path numbers
// are removed from advertisements.
type RemovePrivateAsOption string

const (
	REMOVE_PRIVATE_AS_OPTION_ALL     RemovePrivateAsOption = "all"
	REMOVE_PRIVATE_AS_OPTION_REPLACE RemovePrivateAsOption = "replace"
)

var RemovePrivateAsOptionToIntMap = map[RemovePrivateAsOption]int{
	REMOVE_PRIVATE_AS_OPTION_ALL:     0,
	REMOVE_PRIVATE_AS_OPTION_REPLACE: 1,
}

var IntToRemovePrivateAsOptionMap = map[int]RemovePrivateAsOption{
	0: REMOVE_PRIVATE_AS_OPTION_ALL,
	1: REMOVE_PRIVATE_AS_OPTION_REPLACE,
}

func (v RemovePrivateAsOption) Validate() error {
	if _, ok := RemovePrivateAsOptionToIntMap[v]; !ok {
		return fmt.Errorf("invalid RemovePrivateAsOption: %s", v)
	}
	return nil
}

func (v RemovePrivateAsOption) ToInt() int {
	i, ok := RemovePrivateAsOptionToIntMap[v]
	if !ok {
		return -1
	}
	return i
}

// typedef for identity bgp-types:community-type.
// type describing variations of community attributes:
// STANDARD: standard BGP community [rfc1997]
// EXTENDED: extended BGP community [rfc4360]
// BOTH: both standard and extended community.
type CommunityType string

const (
	COMMUNITY_TYPE_STANDARD CommunityType = "standard"
	COMMUNITY_TYPE_EXTENDED CommunityType = "extended"
	COMMUNITY_TYPE_BOTH     CommunityType = "both"
	COMMUNITY_TYPE_NONE     CommunityType = "none"
)

var CommunityTypeToIntMap = map[CommunityType]int{
	COMMUNITY_TYPE_STANDARD: 0,
	COMMUNITY_TYPE_EXTENDED: 1,
	COMMUNITY_TYPE_BOTH:     2,
	COMMUNITY_TYPE_NONE:     3,
}

var IntToCommunityTypeMap = map[int]CommunityType{
	0: COMMUNITY_TYPE_STANDARD,
	1: COMMUNITY_TYPE_EXTENDED,
	2: COMMUNITY_TYPE_BOTH,
	3: COMMUNITY_TYPE_NONE,
}

func (v CommunityType) Validate() error {
	if _, ok := CommunityTypeToIntMap[v]; !ok {
		return fmt.Errorf("invalid CommunityType: %s", v)
	}
	return nil
}

func (v CommunityType) ToInt() int {
	i, ok := CommunityTypeToIntMap[v]
	if !ok {
		return -1
	}
	return i
}

// typedef for identity bgp-types:peer-type.
// labels a peer or peer group as explicitly internal or
// external.
type PeerType string

const (
	PEER_TYPE_INTERNAL PeerType = "internal"
	PEER_TYPE_EXTERNAL PeerType = "external"
)

var PeerTypeToIntMap = map[PeerType]int{
	PEER_TYPE_INTERNAL: 0,
	PEER_TYPE_EXTERNAL: 1,
}

var IntToPeerTypeMap = map[int]PeerType{
	0: PEER_TYPE_INTERNAL,
	1: PEER_TYPE_EXTERNAL,
}

func (v PeerType) Validate() error {
	if _, ok := PeerTypeToIntMap[v]; !ok {
		return fmt.Errorf("invalid PeerType: %s", v)
	}
	return nil
}

func (v PeerType) ToInt() int {
	i, ok := PeerTypeToIntMap[v]
	if !ok {
		return -1
	}
	return i
}

// typedef for identity bgp-types:afi-safi-type.
// Base identity type for AFI,SAFI tuples for BGP-4.
type AfiSafiType string

const (
	AFI_SAFI_TYPE_IPV4_UNICAST          AfiSafiType = "ipv4-unicast"
	AFI_SAFI_TYPE_IPV6_UNICAST          AfiSafiType = "ipv6-unicast"
	AFI_SAFI_TYPE_IPV4_LABELLED_UNICAST AfiSafiType = "ipv4-labelled-unicast"
	AFI_SAFI_TYPE_IPV6_LABELLED_UNICAST AfiSafiType = "ipv6-labelled-unicast"
	AFI_SAFI_TYPE_L3VPN_IPV4_UNICAST    AfiSafiType = "l3vpn-ipv4-unicast"
	AFI_SAFI_TYPE_L3VPN_IPV6_UNICAST    AfiSafiType = "l3vpn-ipv6-unicast"
	AFI_SAFI_TYPE_L3VPN_IPV4_MULTICAST  AfiSafiType = "l3vpn-ipv4-multicast"
	AFI_SAFI_TYPE_L3VPN_IPV6_MULTICAST  AfiSafiType = "l3vpn-ipv6-multicast"
	AFI_SAFI_TYPE_L2VPN_VPLS            AfiSafiType = "l2vpn-vpls"
	AFI_SAFI_TYPE_L2VPN_EVPN            AfiSafiType = "l2vpn-evpn"
	AFI_SAFI_TYPE_IPV4_MULTICAST        AfiSafiType = "ipv4-multicast"
	AFI_SAFI_TYPE_IPV6_MULTICAST        AfiSafiType = "ipv6-multicast"
	AFI_SAFI_TYPE_RTC                   AfiSafiType = "rtc"
	AFI_SAFI_TYPE_IPV4_ENCAP            AfiSafiType = "ipv4-encap"
	AFI_SAFI_TYPE_IPV6_ENCAP            AfiSafiType = "ipv6-encap"
	AFI_SAFI_TYPE_IPV4_FLOWSPEC         AfiSafiType = "ipv4-flowspec"
	AFI_SAFI_TYPE_L3VPN_IPV4_FLOWSPEC   AfiSafiType = "l3vpn-ipv4-flowspec"
	AFI_SAFI_TYPE_IPV6_FLOWSPEC         AfiSafiType = "ipv6-flowspec"
	AFI_SAFI_TYPE_L3VPN_IPV6_FLOWSPEC   AfiSafiType = "l3vpn-ipv6-flowspec"
	AFI_SAFI_TYPE_L2VPN_FLOWSPEC        AfiSafiType = "l2vpn-flowspec"
	AFI_SAFI_TYPE_IPV4_SRPOLICY         AfiSafiType = "ipv4-srpolicy"
	AFI_SAFI_TYPE_IPV6_SRPOLICY         AfiSafiType = "ipv6-srpolicy"
	AFI_SAFI_TYPE_OPAQUE                AfiSafiType = "opaque"
	AFI_SAFI_TYPE_LS                    AfiSafiType = "ls"
	AFI_SAFI_TYPE_IPV4_MUP              AfiSafiType = "ipv4-mup"
	AFI_SAFI_TYPE_IPV6_MUP              AfiSafiType = "ipv6-mup"
)

var AfiSafiTypeToIntMap = map[AfiSafiType]int{
	AFI_SAFI_TYPE_IPV4_UNICAST:          0,
	AFI_SAFI_TYPE_IPV6_UNICAST:          1,
	AFI_SAFI_TYPE_IPV4_LABELLED_UNICAST: 2,
	AFI_SAFI_TYPE_IPV6_LABELLED_UNICAST: 3,
	AFI_SAFI_TYPE_L3VPN_IPV4_UNICAST:    4,
	AFI_SAFI_TYPE_L3VPN_IPV6_UNICAST:    5,
	AFI_SAFI_TYPE_L3VPN_IPV4_MULTICAST:  6,
	AFI_SAFI_TYPE_L3VPN_IPV6_MULTICAST:  7,
	AFI_SAFI_TYPE_L2VPN_VPLS:            8,
	AFI_SAFI_TYPE_L2VPN_EVPN:            9,
	AFI_SAFI_TYPE_IPV4_MULTICAST:        10,
	AFI_SAFI_TYPE_IPV6_MULTICAST:        11,
	AFI_SAFI_TYPE_RTC:                   12,
	AFI_SAFI_TYPE_IPV4_ENCAP:            13,
	AFI_SAFI_TYPE_IPV6_ENCAP:            14,
	AFI_SAFI_TYPE_IPV4_FLOWSPEC:         15,
	AFI_SAFI_TYPE_L3VPN_IPV4_FLOWSPEC:   16,
	AFI_SAFI_TYPE_IPV6_FLOWSPEC:         17,
	AFI_SAFI_TYPE_L3VPN_IPV6_FLOWSPEC:   18,
	AFI_SAFI_TYPE_L2VPN_FLOWSPEC:        19,
	AFI_SAFI_TYPE_IPV4_SRPOLICY:         20,
	AFI_SAFI_TYPE_IPV6_SRPOLICY:         21,
	AFI_SAFI_TYPE_OPAQUE:                22,
	AFI_SAFI_TYPE_LS:                    23,
	AFI_SAFI_TYPE_IPV4_MUP:              24,
	AFI_SAFI_TYPE_IPV6_MUP:              25,
}

var IntToAfiSafiTypeMap = map[int]AfiSafiType{
	0:  AFI_SAFI_TYPE_IPV4_UNICAST,
	1:  AFI_SAFI_TYPE_IPV6_UNICAST,
	2:  AFI_SAFI_TYPE_IPV4_LABELLED_UNICAST,
	3:  AFI_SAFI_TYPE_IPV6_LABELLED_UNICAST,
	4:  AFI_SAFI_TYPE_L3VPN_IPV4_UNICAST,
	5:  AFI_SAFI_TYPE_L3VPN_IPV6_UNICAST,
	6:  AFI_SAFI_TYPE_L3VPN_IPV4_MULTICAST,
	7:  AFI_SAFI_TYPE_L3VPN_IPV6_MULTICAST,
	8:  AFI_SAFI_TYPE_L2VPN_VPLS,
	9:  AFI_SAFI_TYPE_L2VPN_EVPN,
	10: AFI_SAFI_TYPE_IPV4_MULTICAST,
	11: AFI_SAFI_TYPE_IPV6_MULTICAST,
	12: AFI_SAFI_TYPE_RTC,
	13: AFI_SAFI_TYPE_IPV4_ENCAP,
	14: AFI_SAFI_TYPE_IPV6_ENCAP,
	15: AFI_SAFI_TYPE_IPV4_FLOWSPEC,
	16: AFI_SAFI_TYPE_L3VPN_IPV4_FLOWSPEC,
	17: AFI_SAFI_TYPE_IPV6_FLOWSPEC,
	18: AFI_SAFI_TYPE_L3VPN_IPV6_FLOWSPEC,
	19: AFI_SAFI_TYPE_L2VPN_FLOWSPEC,
	20: AFI_SAFI_TYPE_IPV4_SRPOLICY,
	21: AFI_SAFI_TYPE_IPV6_SRPOLICY,
	22: AFI_SAFI_TYPE_OPAQUE,
	23: AFI_SAFI_TYPE_LS,
	24: AFI_SAFI_TYPE_IPV4_MUP,
	25: AFI_SAFI_TYPE_IPV6_MUP,
}

func (v AfiSafiType) Validate() error {
	if _, ok := AfiSafiTypeToIntMap[v]; !ok {
		return fmt.Errorf("invalid AfiSafiType: %s", v)
	}
	return nil
}

func (v AfiSafiType) ToInt() int {
	i, ok := AfiSafiTypeToIntMap[v]
	if !ok {
		return -1
	}
	return i
}

// typedef for identity bgp-types:bgp-capability.
// Base identity for a BGP capability.
type BgpCapability string

const (
	BGP_CAPABILITY_MPBGP            BgpCapability = "mpbgp"
	BGP_CAPABILITY_ROUTE_REFRESH    BgpCapability = "route-refresh"
	BGP_CAPABILITY_ASN32            BgpCapability = "asn32"
	BGP_CAPABILITY_GRACEFUL_RESTART BgpCapability = "graceful-restart"
	BGP_CAPABILITY_ADD_PATHS        BgpCapability = "add-paths"
)

var BgpCapabilityToIntMap = map[BgpCapability]int{
	BGP_CAPABILITY_MPBGP:            0,
	BGP_CAPABILITY_ROUTE_REFRESH:    1,
	BGP_CAPABILITY_ASN32:            2,
	BGP_CAPABILITY_GRACEFUL_RESTART: 3,
	BGP_CAPABILITY_ADD_PATHS:        4,
}

var IntToBgpCapabilityMap = map[int]BgpCapability{
	0: BGP_CAPABILITY_MPBGP,
	1: BGP_CAPABILITY_ROUTE_REFRESH,
	2: BGP_CAPABILITY_ASN32,
	3: BGP_CAPABILITY_GRACEFUL_RESTART,
	4: BGP_CAPABILITY_ADD_PATHS,
}

func (v BgpCapability) Validate() error {
	if _, ok := BgpCapabilityToIntMap[v]; !ok {
		return fmt.Errorf("invalid BgpCapability: %s", v)
	}
	return nil
}

func (v BgpCapability) ToInt() int {
	i, ok := BgpCapabilityToIntMap[v]
	if !ok {
		return -1
	}
	return i
}

// typedef for identity rpol:route-type.
// Condition to check the route type in the route update.
type RouteType string

const (
	ROUTE_TYPE_NONE     RouteType = "none"
	ROUTE_TYPE_INTERNAL RouteType = "internal"
	ROUTE_TYPE_EXTERNAL RouteType = "external"
	ROUTE_TYPE_LOCAL    RouteType = "local"
)

var RouteTypeToIntMap = map[RouteType]int{
	ROUTE_TYPE_NONE:     0,
	ROUTE_TYPE_INTERNAL: 1,
	ROUTE_TYPE_EXTERNAL: 2,
	ROUTE_TYPE_LOCAL:    3,
}

var IntToRouteTypeMap = map[int]RouteType{
	0: ROUTE_TYPE_NONE,
	1: ROUTE_TYPE_INTERNAL,
	2: ROUTE_TYPE_EXTERNAL,
	3: ROUTE_TYPE_LOCAL,
}

func (v RouteType) Validate() error {
	if _, ok := RouteTypeToIntMap[v]; !ok {
		return fmt.Errorf("invalid RouteType: %s", v)
	}
	return nil
}

func (v RouteType) ToInt() int {
	i, ok := RouteTypeToIntMap[v]
	if !ok {
		return -1
	}
	return i
}

// typedef for identity bgp:session-state.
// Operational state of the BGP peer.
type SessionState string

const (
	SESSION_STATE_IDLE        SessionState = "idle"
	SESSION_STATE_CONNECT     SessionState = "connect"
	SESSION_STATE_ACTIVE      SessionState = "active"
	SESSION_STATE_OPENSENT    SessionState = "opensent"
	SESSION_STATE_OPENCONFIRM SessionState = "openconfirm"
	SESSION_STATE_ESTABLISHED SessionState = "established"
)

var SessionStateToIntMap = map[SessionState]int{
	SESSION_STATE_IDLE:        0,
	SESSION_STATE_CONNECT:     1,
	SESSION_STATE_ACTIVE:      2,
	SESSION_STATE_OPENSENT:    3,
	SESSION_STATE_OPENCONFIRM: 4,
	SESSION_STATE_ESTABLISHED: 5,
}

var IntToSessionStateMap = map[int]SessionState{
	0: SESSION_STATE_IDLE,
	1: SESSION_STATE_CONNECT,
	2: SESSION_STATE_ACTIVE,
	3: SESSION_STATE_OPENSENT,
	4: SESSION_STATE_OPENCONFIRM,
	5: SESSION_STATE_ESTABLISHED,
}

func (v SessionState) Validate() error {
	if _, ok := SessionStateToIntMap[v]; !ok {
		return fmt.Errorf("invalid SessionState: %s", v)
	}
	return nil
}

func (v SessionState) ToInt() int {
	i, ok := SessionStateToIntMap[v]
	if !ok {
		return -1
	}
	return i
}

// struct for container gobgp:config.
// Configuration parameters for TTL Security.
type TtlSecurityConfig struct {
	// original -> gobgp:enabled
	// gobgp:enabled's original type is boolean.
	// Enable features for TTL Security.
	Enabled bool `mapstructure:"enabled" json:"enabled,omitempty"`
	// original -> gobgp:ttl-min
	// Reference to the port of the BMP server.
	TtlMin uint8 `mapstructure:"ttl-min" json:"ttl-min,omitempty"`
}

func (lhs *TtlSecurityConfig) Equal(rhs *TtlSecurityConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Enabled != rhs.Enabled {
		return false
	}
	if lhs.TtlMin != rhs.TtlMin {
		return false
	}
	return true
}

// struct for container gobgp:ttl-security.
// Configure TTL Security feature.
type TtlSecurity struct {
	// original -> gobgp:ttl-security-config
	// Configuration parameters for TTL Security.
	Config TtlSecurityConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> gobgp:ttl-security-state
	// State information for TTL Security.
	State TtlSecurityState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *TtlSecurity) Equal(rhs *TtlSecurity) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp-op:prefixes.
// Prefix counters for the BGP session.
type Prefixes struct {
	// original -> bgp-op:received
	// The number of prefixes received from the neighbor.
	Received uint32 `mapstructure:"received" json:"received,omitempty"`
	// original -> bgp-op:sent
	// The number of prefixes advertised to the neighbor.
	Sent uint32 `mapstructure:"sent" json:"sent,omitempty"`
	// original -> bgp-op:installed
	// The number of advertised prefixes installed in the
	// Loc-RIB.
	Installed uint32 `mapstructure:"installed" json:"installed,omitempty"`
}

func (lhs *Prefixes) Equal(rhs *Prefixes) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Received != rhs.Received {
		return false
	}
	if lhs.Sent != rhs.Sent {
		return false
	}
	if lhs.Installed != rhs.Installed {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information associated with ADD_PATHS.
type AddPathsState struct {
	// original -> bgp:receive
	// bgp:receive's original type is boolean.
	// Enable ability to receive multiple path advertisements
	// for an NLRI from the neighbor or group.
	Receive bool `mapstructure:"receive" json:"receive,omitempty"`
	// original -> bgp:send-max
	// The maximum number of paths to advertise to neighbors
	// for a single NLRI.
	SendMax uint8 `mapstructure:"send-max" json:"send-max,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters relating to ADD_PATHS.
type AddPathsConfig struct {
	// original -> bgp:receive
	// bgp:receive's original type is boolean.
	// Enable ability to receive multiple path advertisements
	// for an NLRI from the neighbor or group.
	Receive bool `mapstructure:"receive" json:"receive,omitempty"`
	// original -> bgp:send-max
	// The maximum number of paths to advertise to neighbors
	// for a single NLRI.
	SendMax uint8 `mapstructure:"send-max" json:"send-max,omitempty"`
}

func (lhs *AddPathsConfig) Equal(rhs *AddPathsConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Receive != rhs.Receive {
		return false
	}
	if lhs.SendMax != rhs.SendMax {
		return false
	}
	return true
}

// struct for container bgp:add-paths.
// Parameters relating to the advertisement and receipt of
// multiple paths for a single NLRI (add-paths).
type AddPaths struct {
	// original -> bgp:add-paths-config
	// Configuration parameters relating to ADD_PATHS.
	Config AddPathsConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:add-paths-state
	// State information associated with ADD_PATHS.
	State AddPathsState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *AddPaths) Equal(rhs *AddPaths) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information relating to the AS_PATH manipulation
// mechanisms for the BGP peer or group.
type AsPathOptionsState struct {
	// original -> bgp:allow-own-as
	// Specify the number of occurrences of the local BGP speaker's
	// AS that can occur within the AS_PATH before it is rejected.
	AllowOwnAs uint8 `mapstructure:"allow-own-as" json:"allow-own-as,omitempty"`
	// original -> bgp:replace-peer-as
	// bgp:replace-peer-as's original type is boolean.
	// Replace occurrences of the peer's AS in the AS_PATH
	// with the local autonomous system number.
	ReplacePeerAs bool `mapstructure:"replace-peer-as" json:"replace-peer-as,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters relating to AS_PATH manipulation
// for the BGP peer or group.
type AsPathOptionsConfig struct {
	// original -> bgp:allow-own-as
	// Specify the number of occurrences of the local BGP speaker's
	// AS that can occur within the AS_PATH before it is rejected.
	AllowOwnAs uint8 `mapstructure:"allow-own-as" json:"allow-own-as,omitempty"`
	// original -> bgp:replace-peer-as
	// bgp:replace-peer-as's original type is boolean.
	// Replace occurrences of the peer's AS in the AS_PATH
	// with the local autonomous system number.
	ReplacePeerAs bool `mapstructure:"replace-peer-as" json:"replace-peer-as,omitempty"`
}

func (lhs *AsPathOptionsConfig) Equal(rhs *AsPathOptionsConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.AllowOwnAs != rhs.AllowOwnAs {
		return false
	}
	if lhs.ReplacePeerAs != rhs.ReplacePeerAs {
		return false
	}
	return true
}

// struct for container bgp:as-path-options.
// AS_PATH manipulation parameters for the BGP neighbor or
// group.
type AsPathOptions struct {
	// original -> bgp:as-path-options-config
	// Configuration parameters relating to AS_PATH manipulation
	// for the BGP peer or group.
	Config AsPathOptionsConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:as-path-options-state
	// State information relating to the AS_PATH manipulation
	// mechanisms for the BGP peer or group.
	State AsPathOptionsState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *AsPathOptions) Equal(rhs *AsPathOptions) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information for eBGP multihop, for the BGP neighbor
// or group.
type EbgpMultihopState struct {
	// original -> bgp:enabled
	// bgp:enabled's original type is boolean.
	// When enabled the referenced group or neighbors are permitted
	// to be indirectly connected - including cases where the TTL
	// can be decremented between the BGP peers.
	Enabled bool `mapstructure:"enabled" json:"enabled,omitempty"`
	// original -> bgp:multihop-ttl
	// Time-to-live value to use when packets are sent to the
	// referenced group or neighbors and ebgp-multihop is enabled.
	MultihopTtl uint8 `mapstructure:"multihop-ttl" json:"multihop-ttl,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters relating to eBGP multihop for the
// BGP neighbor or group.
type EbgpMultihopConfig struct {
	// original -> bgp:enabled
	// bgp:enabled's original type is boolean.
	// When enabled the referenced group or neighbors are permitted
	// to be indirectly connected - including cases where the TTL
	// can be decremented between the BGP peers.
	Enabled bool `mapstructure:"enabled" json:"enabled,omitempty"`
	// original -> bgp:multihop-ttl
	// Time-to-live value to use when packets are sent to the
	// referenced group or neighbors and ebgp-multihop is enabled.
	MultihopTtl uint8 `mapstructure:"multihop-ttl" json:"multihop-ttl,omitempty"`
}

func (lhs *EbgpMultihopConfig) Equal(rhs *EbgpMultihopConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Enabled != rhs.Enabled {
		return false
	}
	if lhs.MultihopTtl != rhs.MultihopTtl {
		return false
	}
	return true
}

// struct for container bgp:ebgp-multihop.
// eBGP multi-hop parameters for the BGP neighbor or group.
type EbgpMultihop struct {
	// original -> bgp:ebgp-multihop-config
	// Configuration parameters relating to eBGP multihop for the
	// BGP neighbor or group.
	Config EbgpMultihopConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:ebgp-multihop-state
	// State information for eBGP multihop, for the BGP neighbor
	// or group.
	State EbgpMultihopState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *EbgpMultihop) Equal(rhs *EbgpMultihop) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information relating to logging for the BGP neighbor
// or group.
type LoggingOptionsState struct {
	// original -> bgp:log-neighbor-state-changes
	// bgp:log-neighbor-state-changes's original type is boolean.
	// Configure logging of peer state changes.  Default is
	// to enable logging of peer state changes.
	LogNeighborStateChanges bool `mapstructure:"log-neighbor-state-changes" json:"log-neighbor-state-changes,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters enabling or modifying logging
// for events relating to the BGP neighbor or group.
type LoggingOptionsConfig struct {
	// original -> bgp:log-neighbor-state-changes
	// bgp:log-neighbor-state-changes's original type is boolean.
	// Configure logging of peer state changes.  Default is
	// to enable logging of peer state changes.
	LogNeighborStateChanges bool `mapstructure:"log-neighbor-state-changes" json:"log-neighbor-state-changes,omitempty"`
}

func (lhs *LoggingOptionsConfig) Equal(rhs *LoggingOptionsConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.LogNeighborStateChanges != rhs.LogNeighborStateChanges {
		return false
	}
	return true
}

// struct for container bgp:logging-options.
// Logging options for events related to the BGP neighbor or
// group.
type LoggingOptions struct {
	// original -> bgp:logging-options-config
	// Configuration parameters enabling or modifying logging
	// for events relating to the BGP neighbor or group.
	Config LoggingOptionsConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:logging-options-state
	// State information relating to logging for the BGP neighbor
	// or group.
	State LoggingOptionsState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *LoggingOptions) Equal(rhs *LoggingOptions) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information relating to enhanced error handling
// mechanisms for the BGP neighbor or group.
type ErrorHandlingState struct {
	// original -> bgp:treat-as-withdraw
	// bgp:treat-as-withdraw's original type is boolean.
	// Specify whether erroneous UPDATE messages for which the
	// NLRI can be extracted are reated as though the NLRI is
	// withdrawn - avoiding session reset.
	TreatAsWithdraw bool `mapstructure:"treat-as-withdraw" json:"treat-as-withdraw,omitempty"`
	// original -> bgp-op:erroneous-update-messages
	// The number of BGP UPDATE messages for which the
	// treat-as-withdraw mechanism has been applied based
	// on erroneous message contents.
	ErroneousUpdateMessages uint32 `mapstructure:"erroneous-update-messages" json:"erroneous-update-messages,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters enabling or modifying the
// behavior or enhanced error handling mechanisms for the BGP
// neighbor or group.
type ErrorHandlingConfig struct {
	// original -> bgp:treat-as-withdraw
	// bgp:treat-as-withdraw's original type is boolean.
	// Specify whether erroneous UPDATE messages for which the
	// NLRI can be extracted are reated as though the NLRI is
	// withdrawn - avoiding session reset.
	TreatAsWithdraw bool `mapstructure:"treat-as-withdraw" json:"treat-as-withdraw,omitempty"`
}

func (lhs *ErrorHandlingConfig) Equal(rhs *ErrorHandlingConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.TreatAsWithdraw != rhs.TreatAsWithdraw {
		return false
	}
	return true
}

// struct for container bgp:error-handling.
// Error handling parameters used for the BGP neighbor or
// group.
type ErrorHandling struct {
	// original -> bgp:error-handling-config
	// Configuration parameters enabling or modifying the
	// behavior or enhanced error handling mechanisms for the BGP
	// neighbor or group.
	Config ErrorHandlingConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:error-handling-state
	// State information relating to enhanced error handling
	// mechanisms for the BGP neighbor or group.
	State ErrorHandlingState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *ErrorHandling) Equal(rhs *ErrorHandling) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information relating to the transport session(s)
// used for the BGP neighbor or group.
type TransportState struct {
	// original -> bgp:tcp-mss
	// Sets the max segment size for BGP TCP sessions.
	TcpMss uint16 `mapstructure:"tcp-mss" json:"tcp-mss,omitempty"`
	// original -> bgp:mtu-discovery
	// bgp:mtu-discovery's original type is boolean.
	// Turns path mtu discovery for BGP TCP sessions on (true)
	// or off (false).
	MtuDiscovery bool `mapstructure:"mtu-discovery" json:"mtu-discovery,omitempty"`
	// original -> bgp:passive-mode
	// bgp:passive-mode's original type is boolean.
	// Wait for peers to issue requests to open a BGP session,
	// rather than initiating sessions from the local router.
	PassiveMode bool `mapstructure:"passive-mode" json:"passive-mode,omitempty"`
	// original -> bgp:local-address
	// bgp:local-address's original type is union.
	// Set the local IP (either IPv4 or IPv6) address to use
	// for the session when sending BGP update messages.  This
	// may be expressed as either an IP address or reference
	// to the name of an interface.
	LocalAddress string `mapstructure:"local-address" json:"local-address,omitempty"`
	// original -> bgp-op:local-port
	// bgp-op:local-port's original type is inet:port-number.
	// Local TCP port being used for the TCP session supporting
	// the BGP session.
	LocalPort uint16 `mapstructure:"local-port" json:"local-port,omitempty"`
	// original -> bgp-op:remote-address
	// bgp-op:remote-address's original type is inet:ip-address.
	// Remote address to which the BGP session has been
	// established.
	RemoteAddress string `mapstructure:"remote-address" json:"remote-address,omitempty"`
	// original -> bgp-op:remote-port
	// bgp-op:remote-port's original type is inet:port-number.
	// Remote port being used by the peer for the TCP session
	// supporting the BGP session.
	RemotePort uint16 `mapstructure:"remote-port" json:"remote-port,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters relating to the transport
// session(s) used for the BGP neighbor or group.
type TransportConfig struct {
	// original -> bgp:tcp-mss
	// Sets the max segment size for BGP TCP sessions.
	TcpMss uint16 `mapstructure:"tcp-mss" json:"tcp-mss,omitempty"`
	// original -> bgp:mtu-discovery
	// bgp:mtu-discovery's original type is boolean.
	// Turns path mtu discovery for BGP TCP sessions on (true)
	// or off (false).
	MtuDiscovery bool `mapstructure:"mtu-discovery" json:"mtu-discovery,omitempty"`
	// original -> bgp:passive-mode
	// bgp:passive-mode's original type is boolean.
	// Wait for peers to issue requests to open a BGP session,
	// rather than initiating sessions from the local router.
	PassiveMode bool `mapstructure:"passive-mode" json:"passive-mode,omitempty"`
	// original -> bgp:local-address
	// bgp:local-address's original type is union.
	// Set the local IP (either IPv4 or IPv6) address to use
	// for the session when sending BGP update messages.  This
	// may be expressed as either an IP address or reference
	// to the name of an interface.
	LocalAddress string `mapstructure:"local-address" json:"local-address,omitempty"`
	// original -> gobgp:local-port
	// gobgp:local-port's original type is inet:port-number.
	// Set the local port (if available) to use for the session.
	LocalPort uint16 `mapstructure:"local-port" json:"local-port,omitempty"`
	// original -> gobgp:remote-port
	// gobgp:remote-port's original type is inet:port-number.
	RemotePort uint16 `mapstructure:"remote-port" json:"remote-port,omitempty"`
	// original -> gobgp:ttl
	// TTL value for BGP packets.
	Ttl uint8 `mapstructure:"ttl" json:"ttl,omitempty"`
	// original -> gobgp:bind-interface
	// Interface name for binding.
	BindInterface string `mapstructure:"bind-interface" json:"bind-interface,omitempty"`
}

func (lhs *TransportConfig) Equal(rhs *TransportConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.TcpMss != rhs.TcpMss {
		return false
	}
	if lhs.MtuDiscovery != rhs.MtuDiscovery {
		return false
	}
	if lhs.PassiveMode != rhs.PassiveMode {
		return false
	}
	if lhs.LocalAddress != rhs.LocalAddress {
		return false
	}
	if lhs.LocalPort != rhs.LocalPort {
		return false
	}
	if lhs.RemotePort != rhs.RemotePort {
		return false
	}
	if lhs.Ttl != rhs.Ttl {
		return false
	}
	if lhs.BindInterface != rhs.BindInterface {
		return false
	}
	return true
}

// struct for container bgp:transport.
// Transport session parameters for the BGP neighbor or group.
type Transport struct {
	// original -> bgp:transport-config
	// Configuration parameters relating to the transport
	// session(s) used for the BGP neighbor or group.
	Config TransportConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:transport-state
	// State information relating to the transport session(s)
	// used for the BGP neighbor or group.
	State TransportState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *Transport) Equal(rhs *Transport) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information relating to the timers used for the BGP
// neighbor or group.
type TimersState struct {
	// original -> bgp:connect-retry
	// bgp:connect-retry's original type is decimal64.
	// Time interval in seconds between attempts to establish a
	// session with the peer.
	ConnectRetry float64 `mapstructure:"connect-retry" json:"connect-retry,omitempty"`
	// original -> bgp:hold-time
	// bgp:hold-time's original type is decimal64.
	// Time interval in seconds that a BGP session will be
	// considered active in the absence of keepalive or other
	// messages from the peer.  The hold-time is typically
	// set to 3x the keepalive-interval.
	HoldTime float64 `mapstructure:"hold-time" json:"hold-time,omitempty"`
	// original -> bgp:keepalive-interval
	// bgp:keepalive-interval's original type is decimal64.
	// Time interval in seconds between transmission of keepalive
	// messages to the neighbor.  Typically set to 1/3 the
	// hold-time.
	KeepaliveInterval float64 `mapstructure:"keepalive-interval" json:"keepalive-interval,omitempty"`
	// original -> bgp:minimum-advertisement-interval
	// bgp:minimum-advertisement-interval's original type is decimal64.
	// Minimum time which must elapse between subsequent UPDATE
	// messages relating to a common set of NLRI being transmitted
	// to a peer. This timer is referred to as
	// MinRouteAdvertisementIntervalTimer by RFC 4721 and serves to
	// reduce the number of UPDATE messages transmitted when a
	// particular set of NLRI exhibit instability.
	MinimumAdvertisementInterval float64 `mapstructure:"minimum-advertisement-interval" json:"minimum-advertisement-interval,omitempty"`
	// original -> bgp-op:uptime
	// bgp-op:uptime's original type is yang:timeticks.
	// This timer determines the amount of time since the
	// BGP last transitioned in or out of the Established
	// state.
	Uptime int64 `mapstructure:"uptime" json:"uptime,omitempty"`
	// original -> bgp-op:negotiated-hold-time
	// bgp-op:negotiated-hold-time's original type is decimal64.
	// The negotiated hold-time for the BGP session.
	NegotiatedHoldTime float64 `mapstructure:"negotiated-hold-time" json:"negotiated-hold-time,omitempty"`
	// original -> gobgp:idle-hold-time-after-reset
	// gobgp:idle-hold-time-after-reset's original type is decimal64.
	// Time interval in seconds that a BGP session will be
	// in idle state after neighbor reset operation.
	IdleHoldTimeAfterReset float64 `mapstructure:"idle-hold-time-after-reset" json:"idle-hold-time-after-reset,omitempty"`
	// original -> gobgp:downtime
	// gobgp:downtime's original type is yang:timeticks.
	// This timer determines the amount of time since the
	// BGP last transitioned out of the Established state.
	Downtime int64 `mapstructure:"downtime" json:"downtime,omitempty"`
	// original -> gobgp:update-recv-time
	// The number of seconds elapsed since January 1, 1970 UTC
	// last time the BGP session received an UPDATE message.
	UpdateRecvTime int64 `mapstructure:"update-recv-time" json:"update-recv-time,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters relating to timers used for the
// BGP neighbor or group.
type TimersConfig struct {
	// original -> bgp:connect-retry
	// bgp:connect-retry's original type is decimal64.
	// Time interval in seconds between attempts to establish a
	// session with the peer.
	ConnectRetry float64 `mapstructure:"connect-retry" json:"connect-retry,omitempty"`
	// original -> bgp:hold-time
	// bgp:hold-time's original type is decimal64.
	// Time interval in seconds that a BGP session will be
	// considered active in the absence of keepalive or other
	// messages from the peer.  The hold-time is typically
	// set to 3x the keepalive-interval.
	HoldTime float64 `mapstructure:"hold-time" json:"hold-time,omitempty"`
	// original -> bgp:keepalive-interval
	// bgp:keepalive-interval's original type is decimal64.
	// Time interval in seconds between transmission of keepalive
	// messages to the neighbor.  Typically set to 1/3 the
	// hold-time.
	KeepaliveInterval float64 `mapstructure:"keepalive-interval" json:"keepalive-interval,omitempty"`
	// original -> bgp:minimum-advertisement-interval
	// bgp:minimum-advertisement-interval's original type is decimal64.
	// Minimum time which must elapse between subsequent UPDATE
	// messages relating to a common set of NLRI being transmitted
	// to a peer. This timer is referred to as
	// MinRouteAdvertisementIntervalTimer by RFC 4721 and serves to
	// reduce the number of UPDATE messages transmitted when a
	// particular set of NLRI exhibit instability.
	MinimumAdvertisementInterval float64 `mapstructure:"minimum-advertisement-interval" json:"minimum-advertisement-interval,omitempty"`
	// original -> gobgp:idle-hold-time-after-reset
	// gobgp:idle-hold-time-after-reset's original type is decimal64.
	// Time interval in seconds that a BGP session will be
	// in idle state after neighbor reset operation.
	IdleHoldTimeAfterReset float64 `mapstructure:"idle-hold-time-after-reset" json:"idle-hold-time-after-reset,omitempty"`
}

func (lhs *TimersConfig) Equal(rhs *TimersConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.ConnectRetry != rhs.ConnectRetry {
		return false
	}
	if lhs.HoldTime != rhs.HoldTime {
		return false
	}
	if lhs.KeepaliveInterval != rhs.KeepaliveInterval {
		return false
	}
	if lhs.MinimumAdvertisementInterval != rhs.MinimumAdvertisementInterval {
		return false
	}
	if lhs.IdleHoldTimeAfterReset != rhs.IdleHoldTimeAfterReset {
		return false
	}
	return true
}

// struct for container bgp:timers.
// Timers related to a BGP neighbor or group.
type Timers struct {
	// original -> bgp:timers-config
	// Configuration parameters relating to timers used for the
	// BGP neighbor or group.
	Config TimersConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:timers-state
	// State information relating to the timers used for the BGP
	// neighbor or group.
	State TimersState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *Timers) Equal(rhs *Timers) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp:queues.
// Counters related to queued messages associated with the
// BGP neighbor.
type Queues struct {
	// original -> bgp-op:input
	// The number of messages received from the peer currently
	// queued.
	Input uint32 `mapstructure:"input" json:"input,omitempty"`
	// original -> bgp-op:output
	// The number of messages queued to be sent to the peer.
	Output uint32 `mapstructure:"output" json:"output,omitempty"`
}

func (lhs *Queues) Equal(rhs *Queues) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Input != rhs.Input {
		return false
	}
	if lhs.Output != rhs.Output {
		return false
	}
	return true
}

// struct for container bgp:received.
// Counters for BGP messages received from the neighbor.
type Received struct {
	// original -> bgp-op:UPDATE
	// Number of BGP UPDATE messages announcing, withdrawing
	// or modifying paths exchanged.
	Update uint64 `mapstructure:"update" json:"update,omitempty"`
	// original -> bgp-op:NOTIFICATION
	// Number of BGP NOTIFICATION messages indicating an
	// error condition has occurred exchanged.
	Notification uint64 `mapstructure:"notification" json:"notification,omitempty"`
	// original -> gobgp:OPEN
	// Number of BGP open messages announcing, withdrawing
	// or modifying paths exchanged.
	Open uint64 `mapstructure:"open" json:"open,omitempty"`
	// original -> gobgp:REFRESH
	// Number of BGP Route-Refresh messages indicating an
	// error condition has occurred exchanged.
	Refresh uint64 `mapstructure:"refresh" json:"refresh,omitempty"`
	// original -> gobgp:KEEPALIVE
	// Number of BGP Keepalive messages indicating an
	// error condition has occurred exchanged.
	Keepalive uint64 `mapstructure:"keepalive" json:"keepalive,omitempty"`
	// original -> gobgp:DYNAMIC-CAP
	// Number of BGP dynamic-cap messages indicating an
	// error condition has occurred exchanged.
	DynamicCap uint64 `mapstructure:"dynamic-cap" json:"dynamic-cap,omitempty"`
	// original -> gobgp:WITHDRAW-UPDATE
	// Number of updates subjected to treat-as-withdraw treatment.
	WithdrawUpdate uint32 `mapstructure:"withdraw-update" json:"withdraw-update,omitempty"`
	// original -> gobgp:WITHDRAW-PREFIX
	// Number of prefixes subjected to treat-as-withdraw treatment.
	WithdrawPrefix uint32 `mapstructure:"withdraw-prefix" json:"withdraw-prefix,omitempty"`
	// original -> gobgp:DISCARDED
	// Number of discarded messages indicating an
	// error condition has occurred exchanged.
	Discarded uint64 `mapstructure:"discarded" json:"discarded,omitempty"`
	// original -> gobgp:TOTAL
	// Number of total messages indicating an
	// error condition has occurred exchanged.
	Total uint64 `mapstructure:"total" json:"total,omitempty"`
}

func (lhs *Received) Equal(rhs *Received) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Update != rhs.Update {
		return false
	}
	if lhs.Notification != rhs.Notification {
		return false
	}
	if lhs.Open != rhs.Open {
		return false
	}
	if lhs.Refresh != rhs.Refresh {
		return false
	}
	if lhs.Keepalive != rhs.Keepalive {
		return false
	}
	if lhs.DynamicCap != rhs.DynamicCap {
		return false
	}
	if lhs.WithdrawUpdate != rhs.WithdrawUpdate {
		return false
	}
	if lhs.WithdrawPrefix != rhs.WithdrawPrefix {
		return false
	}
	if lhs.Discarded != rhs.Discarded {
		return false
	}
	if lhs.Total != rhs.Total {
		return false
	}
	return true
}

// struct for container bgp:sent.
// Counters relating to BGP messages sent to the neighbor.
type Sent struct {
	// original -> bgp-op:UPDATE
	// Number of BGP UPDATE messages announcing, withdrawing
	// or modifying paths exchanged.
	Update uint64 `mapstructure:"update" json:"update,omitempty"`
	// original -> bgp-op:NOTIFICATION
	// Number of BGP NOTIFICATION messages indicating an
	// error condition has occurred exchanged.
	Notification uint64 `mapstructure:"notification" json:"notification,omitempty"`
	// original -> gobgp:OPEN
	// Number of BGP open messages announcing, withdrawing
	// or modifying paths exchanged.
	Open uint64 `mapstructure:"open" json:"open,omitempty"`
	// original -> gobgp:REFRESH
	// Number of BGP Route-Refresh messages indicating an
	// error condition has occurred exchanged.
	Refresh uint64 `mapstructure:"refresh" json:"refresh,omitempty"`
	// original -> gobgp:KEEPALIVE
	// Number of BGP Keepalive messages indicating an
	// error condition has occurred exchanged.
	Keepalive uint64 `mapstructure:"keepalive" json:"keepalive,omitempty"`
	// original -> gobgp:DYNAMIC-CAP
	// Number of BGP dynamic-cap messages indicating an
	// error condition has occurred exchanged.
	DynamicCap uint64 `mapstructure:"dynamic-cap" json:"dynamic-cap,omitempty"`
	// original -> gobgp:WITHDRAW-UPDATE
	// Number of updates subjected to treat-as-withdraw treatment.
	WithdrawUpdate uint32 `mapstructure:"withdraw-update" json:"withdraw-update,omitempty"`
	// original -> gobgp:WITHDRAW-PREFIX
	// Number of prefixes subjected to treat-as-withdraw treatment.
	WithdrawPrefix uint32 `mapstructure:"withdraw-prefix" json:"withdraw-prefix,omitempty"`
	// original -> gobgp:DISCARDED
	// Number of discarded messages indicating an
	// error condition has occurred exchanged.
	Discarded uint64 `mapstructure:"discarded" json:"discarded,omitempty"`
	// original -> gobgp:TOTAL
	// Number of total messages indicating an
	// error condition has occurred exchanged.
	Total uint64 `mapstructure:"total" json:"total,omitempty"`
}

func (lhs *Sent) Equal(rhs *Sent) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Update != rhs.Update {
		return false
	}
	if lhs.Notification != rhs.Notification {
		return false
	}
	if lhs.Open != rhs.Open {
		return false
	}
	if lhs.Refresh != rhs.Refresh {
		return false
	}
	if lhs.Keepalive != rhs.Keepalive {
		return false
	}
	if lhs.DynamicCap != rhs.DynamicCap {
		return false
	}
	if lhs.WithdrawUpdate != rhs.WithdrawUpdate {
		return false
	}
	if lhs.WithdrawPrefix != rhs.WithdrawPrefix {
		return false
	}
	if lhs.Discarded != rhs.Discarded {
		return false
	}
	if lhs.Total != rhs.Total {
		return false
	}
	return true
}

// struct for container bgp:messages.
// Counters for BGP messages sent and received from the
// neighbor.
type Messages struct {
	// original -> bgp:sent
	// Counters relating to BGP messages sent to the neighbor.
	Sent Sent `mapstructure:"sent" json:"sent,omitempty"`
	// original -> bgp:received
	// Counters for BGP messages received from the neighbor.
	Received Received `mapstructure:"received" json:"received,omitempty"`
}

func (lhs *Messages) Equal(rhs *Messages) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Sent.Equal(&(rhs.Sent)) {
		return false
	}
	if !lhs.Received.Equal(&(rhs.Received)) {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information relating to the BGP neighbor or group.
type PeerState struct {
	// original -> bgp:peer-as
	// bgp:peer-as's original type is inet:as-number.
	// AS number of the peer.
	PeerAs uint32 `mapstructure:"peer-as" json:"peer-as,omitempty"`
	// original -> bgp:local-as
	// bgp:local-as's original type is inet:as-number.
	// The local autonomous system number that is to be used
	// when establishing sessions with the remote peer or peer
	// group, if this differs from the global BGP router
	// autonomous system number.
	LocalAs uint32 `mapstructure:"local-as" json:"local-as,omitempty"`
	// original -> bgp:peer-type
	// Explicitly designate the peer or peer group as internal
	// (iBGP) or external (eBGP).
	PeerType PeerType `mapstructure:"peer-type" json:"peer-type,omitempty"`
	// original -> bgp:auth-password
	// Configures an MD5 authentication password for use with
	// neighboring devices.
	AuthPassword string `mapstructure:"auth-password" json:"auth-password,omitempty"`
	// original -> bgp:remove-private-as
	// Remove private AS numbers from updates sent to peers.
	RemovePrivateAs RemovePrivateAsOption `mapstructure:"remove-private-as" json:"remove-private-as,omitempty"`
	// original -> bgp:route-flap-damping
	// bgp:route-flap-damping's original type is boolean.
	// Enable route flap damping.
	RouteFlapDamping bool `mapstructure:"route-flap-damping" json:"route-flap-damping,omitempty"`
	// original -> bgp:send-community
	// Specify which types of community should be sent to the
	// neighbor or group. The default is to not send the
	// community attribute.
	SendCommunity CommunityType `mapstructure:"send-community" json:"send-community,omitempty"`
	// original -> bgp:description
	// An optional textual description (intended primarily for use
	// with a peer or group.
	Description string `mapstructure:"description" json:"description,omitempty"`
	// original -> bgp:neighbor-address
	// bgp:neighbor-address's original type is inet:ip-address.
	// Address of the BGP peer, either in IPv4 or IPv6.
	PeerAddress string `mapstructure:"peer-address" json:"peer-address,omitempty"`
	// original -> bgp-op:session-state
	// Operational state of the BGP peer.
	SessionState SessionState `mapstructure:"session-state" json:"session-state,omitempty"`
	// original -> bgp-op:supported-capabilities
	// BGP capabilities negotiated as supported with the peer.
	SupportedCapabilitiesList []BgpCapability `mapstructure:"supported-capabilities-list" json:"supported-capabilities-list,omitempty"`
	// original -> bgp:messages
	// Counters for BGP messages sent and received from the
	// neighbor.
	Messages Messages `mapstructure:"messages" json:"messages,omitempty"`
	// original -> bgp:queues
	// Counters related to queued messages associated with the
	// BGP neighbor.
	Queues Queues `mapstructure:"queues" json:"queues,omitempty"`
	// original -> gobgp:remote-capability
	// original type is list of bgp-capability
	RemoteCapabilityList []bgp.ParameterCapabilityInterface `mapstructure:"remote-capability-list" json:"remote-capability-list,omitempty"`
	// original -> gobgp:local-capability
	// original type is list of bgp-capability
	LocalCapabilityList []bgp.ParameterCapabilityInterface `mapstructure:"local-capability-list" json:"local-capability-list,omitempty"`
	// original -> gobgp:established-count
	// The number of how many the peer became established state.
	EstablishedCount uint32 `mapstructure:"established-count" json:"established-count,omitempty"`
	// original -> gobgp:flops
	// The number of flip-flops.
	Flops uint32 `mapstructure:"flops" json:"flops,omitempty"`
	// original -> gobgp:neighbor-interface
	PeerInterface string `mapstructure:"peer-interface" json:"peer-interface,omitempty"`
	// original -> gobgp:vrf
	Vrf string `mapstructure:"vrf" json:"vrf,omitempty"`
	// original -> gobgp:remote-router-id
	RemoteRouterId string `mapstructure:"remote-router-id" json:"remote-router-id,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters relating to the BGP neighbor or
// group.
type PeerConfig struct {
	// original -> bgp:peer-as
	// bgp:peer-as's original type is inet:as-number.
	// AS number of the peer.
	PeerAs uint32 `mapstructure:"peer-as" json:"peer-as,omitempty"`
	// original -> bgp:local-as
	// bgp:local-as's original type is inet:as-number.
	// The local autonomous system number that is to be used
	// when establishing sessions with the remote peer or peer
	// group, if this differs from the global BGP router
	// autonomous system number.
	LocalAs uint32 `mapstructure:"local-as" json:"local-as,omitempty"`
	// original -> bgp:peer-type
	// Explicitly designate the peer or peer group as internal
	// (iBGP) or external (eBGP).
	PeerType PeerType `mapstructure:"peer-type" json:"peer-type,omitempty"`
	// original -> bgp:auth-password
	// Configures an MD5 authentication password for use with
	// neighboring devices.
	AuthPassword string `mapstructure:"auth-password" json:"auth-password,omitempty"`
	// original -> bgp:remove-private-as
	// Remove private AS numbers from updates sent to peers.
	RemovePrivateAs RemovePrivateAsOption `mapstructure:"remove-private-as" json:"remove-private-as,omitempty"`
	// original -> bgp:route-flap-damping
	// bgp:route-flap-damping's original type is boolean.
	// Enable route flap damping.
	RouteFlapDamping bool `mapstructure:"route-flap-damping" json:"route-flap-damping,omitempty"`
	// original -> bgp:send-community
	// Specify which types of community should be sent to the
	// neighbor or group. The default is to not send the
	// community attribute.
	SendCommunity CommunityType `mapstructure:"send-community" json:"send-community,omitempty"`
	// original -> bgp:description
	// An optional textual description (intended primarily for use
	// with a peer or group.
	Description string `mapstructure:"description" json:"description,omitempty"`
	// original -> bgp:neighbor-address
	// bgp:neighbor-address's original type is inet:ip-address.
	// Address of the BGP peer, either in IPv4 or IPv6.
	PeerAddress string `mapstructure:"peer-address" json:"peer-address,omitempty"`
	// original -> gobgp:neighbor-interface
	PeerInterface string `mapstructure:"peer-interface" json:"peer-interface,omitempty"`
	// original -> gobgp:vrf
	Vrf string `mapstructure:"vrf" json:"vrf,omitempty"`
}

func (lhs *PeerConfig) Equal(rhs *PeerConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.PeerAs != rhs.PeerAs {
		return false
	}
	if lhs.LocalAs != rhs.LocalAs {
		return false
	}
	if lhs.PeerType != rhs.PeerType {
		return false
	}
	if lhs.AuthPassword != rhs.AuthPassword {
		return false
	}
	if lhs.RemovePrivateAs != rhs.RemovePrivateAs {
		return false
	}
	if lhs.RouteFlapDamping != rhs.RouteFlapDamping {
		return false
	}
	if lhs.SendCommunity != rhs.SendCommunity {
		return false
	}
	if lhs.Description != rhs.Description {
		return false
	}
	if lhs.PeerAddress != rhs.PeerAddress {
		return false
	}
	if lhs.PeerInterface != rhs.PeerInterface {
		return false
	}
	if lhs.Vrf != rhs.Vrf {
		return false
	}
	return true
}

// struct for container bgp:neighbor.
// List of BGP neighbors configured on the local system,
// uniquely identified by peer IPv[46] address.
type Peer struct {
	// original -> bgp:neighbor-address
	// original -> bgp:neighbor-config
	// Configuration parameters relating to the BGP neighbor or
	// group.
	Config PeerConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:neighbor-state
	// State information relating to the BGP neighbor or group.
	State PeerState `mapstructure:"state" json:"state,omitempty"`
	// original -> bgp:timers
	// Timers related to a BGP neighbor or group.
	Timers Timers `mapstructure:"timers" json:"timers,omitempty"`
	// original -> bgp:transport
	// Transport session parameters for the BGP neighbor or group.
	Transport Transport `mapstructure:"transport" json:"transport,omitempty"`
	// original -> bgp:error-handling
	// Error handling parameters used for the BGP neighbor or
	// group.
	ErrorHandling ErrorHandling `mapstructure:"error-handling" json:"error-handling,omitempty"`
	// original -> bgp:logging-options
	// Logging options for events related to the BGP neighbor or
	// group.
	LoggingOptions LoggingOptions `mapstructure:"logging-options" json:"logging-options,omitempty"`
	// original -> bgp:ebgp-multihop
	// eBGP multi-hop parameters for the BGP neighbor or group.
	EbgpMultihop EbgpMultihop `mapstructure:"ebgp-multihop" json:"ebgp-multihop,omitempty"`
	// original -> bgp:as-path-options
	// AS_PATH manipulation parameters for the BGP neighbor or
	// group.
	AsPathOptions AsPathOptions `mapstructure:"as-path-options" json:"as-path-options,omitempty"`
	// original -> bgp:add-paths
	// Parameters relating to the advertisement and receipt of
	// multiple paths for a single NLRI (add-paths).
	AddPaths AddPaths `mapstructure:"add-paths" json:"add-paths,omitempty"`
	// original -> bgp:afi-safis
	// Per-address-family configuration parameters associated with
	// the neighbor or group.
	AfiSafis []AfiSafi `mapstructure:"afi-safis" json:"afi-safis,omitempty"`
	// original -> bgp-mp:use-multiple-paths
	// Parameters related to the use of multiple-paths for the same
	// NLRI when they are received only from this neighbor.
	UseMultiplePaths UseMultiplePaths `mapstructure:"use-multiple-paths" json:"use-multiple-paths,omitempty"`
	// original -> gobgp:ttl-security
	// Configure TTL Security feature.
	TtlSecurity TtlSecurity `mapstructure:"ttl-security" json:"ttl-security,omitempty"`
	// XRDP
	RDPEnabled bool `mapstructure:"rdp-enabled" jason:"rdp-enabled,omitempty"`
}

func (lhs *Peer) Equal(rhs *Peer) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	if !lhs.Timers.Equal(&(rhs.Timers)) {
		return false
	}
	if !lhs.Transport.Equal(&(rhs.Transport)) {
		return false
	}
	if !lhs.ErrorHandling.Equal(&(rhs.ErrorHandling)) {
		return false
	}
	if !lhs.LoggingOptions.Equal(&(rhs.LoggingOptions)) {
		return false
	}
	if !lhs.EbgpMultihop.Equal(&(rhs.EbgpMultihop)) {
		return false
	}
	if !lhs.AsPathOptions.Equal(&(rhs.AsPathOptions)) {
		return false
	}
	if !lhs.AddPaths.Equal(&(rhs.AddPaths)) {
		return false
	}
	if len(lhs.AfiSafis) != len(rhs.AfiSafis) {
		return false
	}
	{
		lmap := make(map[string]*AfiSafi)
		for i, l := range lhs.AfiSafis {
			lmap[mapkey(i, string(l.Config.AfiSafiName))] = &lhs.AfiSafis[i]
		}
		for i, r := range rhs.AfiSafis {
			if l, y := lmap[mapkey(i, string(r.Config.AfiSafiName))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if !lhs.UseMultiplePaths.Equal(&(rhs.UseMultiplePaths)) {
		return false
	}
	if !lhs.TtlSecurity.Equal(&(rhs.TtlSecurity)) {
		return false
	}
	if lhs.RDPEnabled != rhs.RDPEnabled {
		return false
	}
	return true
}

// struct for container gobgp:state.
type RouteTargetMembershipState struct {
	// original -> gobgp:deferral-time
	DeferralTime uint16 `mapstructure:"deferral-time" json:"deferral-time,omitempty"`
}

// struct for container gobgp:config.
type RouteTargetMembershipConfig struct {
	// original -> gobgp:deferral-time
	DeferralTime uint16 `mapstructure:"deferral-time" json:"deferral-time,omitempty"`
}

func (lhs *RouteTargetMembershipConfig) Equal(rhs *RouteTargetMembershipConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.DeferralTime != rhs.DeferralTime {
		return false
	}
	return true
}

// struct for container gobgp:route-target-membership.
type RouteTargetMembership struct {
	// original -> gobgp:route-target-membership-config
	Config RouteTargetMembershipConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> gobgp:route-target-membership-state
	State RouteTargetMembershipState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *RouteTargetMembership) Equal(rhs *RouteTargetMembership) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp-mp:l2vpn-evpn.
// BGP EVPN configuration options.
type L2vpnEvpn struct {
}

func (lhs *L2vpnEvpn) Equal(rhs *L2vpnEvpn) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	return true
}

// struct for container bgp-mp:l2vpn-vpls.
// BGP-signalled VPLS configuration options.
type L2vpnVpls struct {
}

func (lhs *L2vpnVpls) Equal(rhs *L2vpnVpls) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	return true
}

// struct for container bgp-mp:l3vpn-ipv6-multicast.
// Multicast IPv6 L3VPN configuration options.
type L3vpnIpv6Multicast struct {
}

func (lhs *L3vpnIpv6Multicast) Equal(rhs *L3vpnIpv6Multicast) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	return true
}

// struct for container bgp-mp:l3vpn-ipv4-multicast.
// Multicast IPv4 L3VPN configuration options.
type L3vpnIpv4Multicast struct {
}

func (lhs *L3vpnIpv4Multicast) Equal(rhs *L3vpnIpv4Multicast) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	return true
}

// struct for container bgp-mp:l3vpn-ipv6-unicast.
// Unicast IPv6 L3VPN configuration options.
type L3vpnIpv6Unicast struct {
}

func (lhs *L3vpnIpv6Unicast) Equal(rhs *L3vpnIpv6Unicast) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	return true
}

// struct for container bgp-mp:l3vpn-ipv4-unicast.
// Unicast IPv4 L3VPN configuration options.
type L3vpnIpv4Unicast struct {
}

func (lhs *L3vpnIpv4Unicast) Equal(rhs *L3vpnIpv4Unicast) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	return true
}

// struct for container bgp-mp:ipv6-labelled-unicast.
// IPv6 Labelled Unicast configuration options.
type Ipv6LabelledUnicast struct {
}

func (lhs *Ipv6LabelledUnicast) Equal(rhs *Ipv6LabelledUnicast) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	return true
}

// struct for container bgp-mp:ipv4-labelled-unicast.
// IPv4 Labelled Unicast configuration options.
type Ipv4LabelledUnicast struct {
}

func (lhs *Ipv4LabelledUnicast) Equal(rhs *Ipv4LabelledUnicast) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	return true
}

// struct for container bgp-mp:state.
// State information for common IPv4 and IPv6 unicast
// parameters.
type Ipv6UnicastState struct {
	// original -> bgp-mp:send-default-route
	// bgp-mp:send-default-route's original type is boolean.
	// If set to true, send the default-route to the neighbour(s).
	SendDefaultRoute bool `mapstructure:"send-default-route" json:"send-default-route,omitempty"`
}

// struct for container bgp-mp:config.
// Configuration parameters for common IPv4 and IPv6 unicast
// AFI-SAFI options.
type Ipv6UnicastConfig struct {
	// original -> bgp-mp:send-default-route
	// bgp-mp:send-default-route's original type is boolean.
	// If set to true, send the default-route to the neighbour(s).
	SendDefaultRoute bool `mapstructure:"send-default-route" json:"send-default-route,omitempty"`
}

func (lhs *Ipv6UnicastConfig) Equal(rhs *Ipv6UnicastConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.SendDefaultRoute != rhs.SendDefaultRoute {
		return false
	}
	return true
}

// struct for container bgp-mp:ipv6-unicast.
// IPv6 unicast configuration options.
type Ipv6Unicast struct {
	// original -> bgp-mp:ipv6-unicast-config
	// Configuration parameters for common IPv4 and IPv6 unicast
	// AFI-SAFI options.
	Config Ipv6UnicastConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp-mp:ipv6-unicast-state
	// State information for common IPv4 and IPv6 unicast
	// parameters.
	State Ipv6UnicastState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *Ipv6Unicast) Equal(rhs *Ipv6Unicast) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp-mp:state.
// State information for common IPv4 and IPv6 unicast
// parameters.
type Ipv4UnicastState struct {
	// original -> bgp-mp:send-default-route
	// bgp-mp:send-default-route's original type is boolean.
	// If set to true, send the default-route to the neighbour(s).
	SendDefaultRoute bool `mapstructure:"send-default-route" json:"send-default-route,omitempty"`
}

// struct for container bgp-mp:config.
// Configuration parameters for common IPv4 and IPv6 unicast
// AFI-SAFI options.
type Ipv4UnicastConfig struct {
	// original -> bgp-mp:send-default-route
	// bgp-mp:send-default-route's original type is boolean.
	// If set to true, send the default-route to the neighbour(s).
	SendDefaultRoute bool `mapstructure:"send-default-route" json:"send-default-route,omitempty"`
}

func (lhs *Ipv4UnicastConfig) Equal(rhs *Ipv4UnicastConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.SendDefaultRoute != rhs.SendDefaultRoute {
		return false
	}
	return true
}

// struct for container bgp-mp:ipv4-unicast.
// IPv4 unicast configuration options.
type Ipv4Unicast struct {
	// original -> bgp-mp:ipv4-unicast-config
	// Configuration parameters for common IPv4 and IPv6 unicast
	// AFI-SAFI options.
	Config Ipv4UnicastConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp-mp:ipv4-unicast-state
	// State information for common IPv4 and IPv6 unicast
	// parameters.
	State Ipv4UnicastState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *Ipv4Unicast) Equal(rhs *Ipv4Unicast) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp-mp:state.
// State information relating to the AFI-SAFI.
type AfiSafiState struct {
	// original -> bgp-mp:afi-safi-name
	// AFI,SAFI.
	AfiSafiName AfiSafiType `mapstructure:"afi-safi-name" json:"afi-safi-name,omitempty"`
	// original -> bgp-mp:enabled
	// bgp-mp:enabled's original type is boolean.
	// This leaf indicates whether the IPv4 Unicast AFI,SAFI is
	// enabled for the neighbour or group.
	Enabled bool `mapstructure:"enabled" json:"enabled,omitempty"`
	// original -> bgp-op:total-paths
	// Total number of BGP paths within the context.
	TotalPaths uint32 `mapstructure:"total-paths" json:"total-paths,omitempty"`
	// original -> bgp-op:total-prefixes
	// .
	TotalPrefixes uint32 `mapstructure:"total-prefixes" json:"total-prefixes,omitempty"`
	// original -> gobgp:family
	// gobgp:family's original type is route-family.
	// Address family value of AFI-SAFI pair translated from afi-safi-name.
	Family bgp.RouteFamily `mapstructure:"family" json:"family,omitempty"`
}

// struct for container bgp-mp:config.
// Configuration parameters for the AFI-SAFI.
type AfiSafiConfig struct {
	// original -> bgp-mp:afi-safi-name
	// AFI,SAFI.
	AfiSafiName AfiSafiType `mapstructure:"afi-safi-name" json:"afi-safi-name,omitempty"`
	// original -> bgp-mp:enabled
	// bgp-mp:enabled's original type is boolean.
	// This leaf indicates whether the IPv4 Unicast AFI,SAFI is
	// enabled for the neighbour or group.
	Enabled bool `mapstructure:"enabled" json:"enabled,omitempty"`
}

func (lhs *AfiSafiConfig) Equal(rhs *AfiSafiConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.AfiSafiName != rhs.AfiSafiName {
		return false
	}
	if lhs.Enabled != rhs.Enabled {
		return false
	}
	return true
}

// struct for container bgp-mp:afi-safi.
// AFI,SAFI configuration available for the
// neighbour or group.
type AfiSafi struct {
	// original -> bgp-mp:afi-safi-config
	// Configuration parameters for the AFI-SAFI.
	Config AfiSafiConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp-mp:afi-safi-state
	// State information relating to the AFI-SAFI.
	State AfiSafiState `mapstructure:"state" json:"state,omitempty"`
	// original -> bgp-mp:ipv4-unicast
	// IPv4 unicast configuration options.
	Ipv4Unicast Ipv4Unicast `mapstructure:"ipv4-unicast" json:"ipv4-unicast,omitempty"`
	// original -> bgp-mp:ipv6-unicast
	// IPv6 unicast configuration options.
	Ipv6Unicast Ipv6Unicast `mapstructure:"ipv6-unicast" json:"ipv6-unicast,omitempty"`
	// original -> bgp-mp:ipv4-labelled-unicast
	// IPv4 Labelled Unicast configuration options.
	Ipv4LabelledUnicast Ipv4LabelledUnicast `mapstructure:"ipv4-labelled-unicast" json:"ipv4-labelled-unicast,omitempty"`
	// original -> bgp-mp:ipv6-labelled-unicast
	// IPv6 Labelled Unicast configuration options.
	Ipv6LabelledUnicast Ipv6LabelledUnicast `mapstructure:"ipv6-labelled-unicast" json:"ipv6-labelled-unicast,omitempty"`
	// original -> bgp-mp:l3vpn-ipv4-unicast
	// Unicast IPv4 L3VPN configuration options.
	L3vpnIpv4Unicast L3vpnIpv4Unicast `mapstructure:"l3vpn-ipv4-unicast" json:"l3vpn-ipv4-unicast,omitempty"`
	// original -> bgp-mp:l3vpn-ipv6-unicast
	// Unicast IPv6 L3VPN configuration options.
	L3vpnIpv6Unicast L3vpnIpv6Unicast `mapstructure:"l3vpn-ipv6-unicast" json:"l3vpn-ipv6-unicast,omitempty"`
	// original -> bgp-mp:l3vpn-ipv4-multicast
	// Multicast IPv4 L3VPN configuration options.
	L3vpnIpv4Multicast L3vpnIpv4Multicast `mapstructure:"l3vpn-ipv4-multicast" json:"l3vpn-ipv4-multicast,omitempty"`
	// original -> bgp-mp:l3vpn-ipv6-multicast
	// Multicast IPv6 L3VPN configuration options.
	L3vpnIpv6Multicast L3vpnIpv6Multicast `mapstructure:"l3vpn-ipv6-multicast" json:"l3vpn-ipv6-multicast,omitempty"`
	// original -> bgp-mp:l2vpn-vpls
	// BGP-signalled VPLS configuration options.
	L2vpnVpls L2vpnVpls `mapstructure:"l2vpn-vpls" json:"l2vpn-vpls,omitempty"`
	// original -> bgp-mp:l2vpn-evpn
	// BGP EVPN configuration options.
	L2vpnEvpn L2vpnEvpn `mapstructure:"l2vpn-evpn" json:"l2vpn-evpn,omitempty"`
	// original -> bgp-mp:use-multiple-paths
	// Parameters related to the use of multiple paths for the
	// same NLRI.
	UseMultiplePaths UseMultiplePaths `mapstructure:"use-multiple-paths" json:"use-multiple-paths,omitempty"`
	// original -> gobgp:route-target-membership
	RouteTargetMembership RouteTargetMembership `mapstructure:"route-target-membership" json:"route-target-membership,omitempty"`
	// original -> gobgp:add-paths
	// add-paths configuration options related to a particular AFI-SAFI.
	AddPaths AddPaths `mapstructure:"add-paths" json:"add-paths,omitempty"`
	// original -> bgp-mp:ipv4-mup
}

func (lhs *AfiSafi) Equal(rhs *AfiSafi) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	if !lhs.Ipv4Unicast.Equal(&(rhs.Ipv4Unicast)) {
		return false
	}
	if !lhs.Ipv6Unicast.Equal(&(rhs.Ipv6Unicast)) {
		return false
	}
	if !lhs.Ipv4LabelledUnicast.Equal(&(rhs.Ipv4LabelledUnicast)) {
		return false
	}
	if !lhs.Ipv6LabelledUnicast.Equal(&(rhs.Ipv6LabelledUnicast)) {
		return false
	}
	if !lhs.L3vpnIpv4Unicast.Equal(&(rhs.L3vpnIpv4Unicast)) {
		return false
	}
	if !lhs.L3vpnIpv6Unicast.Equal(&(rhs.L3vpnIpv6Unicast)) {
		return false
	}
	if !lhs.L3vpnIpv4Multicast.Equal(&(rhs.L3vpnIpv4Multicast)) {
		return false
	}
	if !lhs.L3vpnIpv6Multicast.Equal(&(rhs.L3vpnIpv6Multicast)) {
		return false
	}
	if !lhs.L2vpnVpls.Equal(&(rhs.L2vpnVpls)) {
		return false
	}
	if !lhs.L2vpnEvpn.Equal(&(rhs.L2vpnEvpn)) {
		return false
	}
	if !lhs.UseMultiplePaths.Equal(&(rhs.UseMultiplePaths)) {
		return false
	}
	if !lhs.RouteTargetMembership.Equal(&(rhs.RouteTargetMembership)) {
		return false
	}
	if !lhs.AddPaths.Equal(&(rhs.AddPaths)) {
		return false
	}
	return true
}

// struct for container bgp-mp:state.
// State information relating to iBGP multipath.
type IbgpState struct {
	// original -> bgp-mp:maximum-paths
	// Maximum number of parallel paths to consider when using
	// iBGP multipath. The default is to use a single path.
	MaximumPaths uint32 `mapstructure:"maximum-paths" json:"maximum-paths,omitempty"`
}

// struct for container bgp-mp:config.
// Configuration parameters relating to iBGP multipath.
type IbgpConfig struct {
	// original -> bgp-mp:maximum-paths
	// Maximum number of parallel paths to consider when using
	// iBGP multipath. The default is to use a single path.
	MaximumPaths uint32 `mapstructure:"maximum-paths" json:"maximum-paths,omitempty"`
}

func (lhs *IbgpConfig) Equal(rhs *IbgpConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.MaximumPaths != rhs.MaximumPaths {
		return false
	}
	return true
}

// struct for container bgp-mp:ibgp.
// Multipath parameters for iBGP.
type Ibgp struct {
	// original -> bgp-mp:ibgp-config
	// Configuration parameters relating to iBGP multipath.
	Config IbgpConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp-mp:ibgp-state
	// State information relating to iBGP multipath.
	State IbgpState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *Ibgp) Equal(rhs *Ibgp) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp-mp:state.
// State information relating to eBGP multipath.
type EbgpState struct {
	// original -> bgp-mp:allow-multiple-as
	// bgp-mp:allow-multiple-as's original type is boolean.
	// Allow multipath to use paths from different neighbouring
	// ASes.  The default is to only consider multiple paths from
	// the same neighbouring AS.
	AllowMultipleAs bool `mapstructure:"allow-multiple-as" json:"allow-multiple-as,omitempty"`
	// original -> bgp-mp:maximum-paths
	// Maximum number of parallel paths to consider when using
	// BGP multipath. The default is use a single path.
	MaximumPaths uint32 `mapstructure:"maximum-paths" json:"maximum-paths,omitempty"`
}

// struct for container bgp-mp:config.
// Configuration parameters relating to eBGP multipath.
type EbgpConfig struct {
	// original -> bgp-mp:allow-multiple-as
	// bgp-mp:allow-multiple-as's original type is boolean.
	// Allow multipath to use paths from different neighbouring
	// ASes.  The default is to only consider multiple paths from
	// the same neighbouring AS.
	AllowMultipleAs bool `mapstructure:"allow-multiple-as" json:"allow-multiple-as,omitempty"`
	// original -> bgp-mp:maximum-paths
	// Maximum number of parallel paths to consider when using
	// BGP multipath. The default is use a single path.
	MaximumPaths uint32 `mapstructure:"maximum-paths" json:"maximum-paths,omitempty"`
}

func (lhs *EbgpConfig) Equal(rhs *EbgpConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.AllowMultipleAs != rhs.AllowMultipleAs {
		return false
	}
	if lhs.MaximumPaths != rhs.MaximumPaths {
		return false
	}
	return true
}

// struct for container bgp-mp:ebgp.
// Multipath parameters for eBGP.
type Ebgp struct {
	// original -> bgp-mp:ebgp-config
	// Configuration parameters relating to eBGP multipath.
	Config EbgpConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp-mp:ebgp-state
	// State information relating to eBGP multipath.
	State EbgpState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *Ebgp) Equal(rhs *Ebgp) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp-mp:state.
// State parameters relating to multipath.
type UseMultiplePathsState struct {
	// original -> bgp-mp:enabled
	// bgp-mp:enabled's original type is boolean.
	// Whether the use of multiple paths for the same NLRI is
	// enabled for the neighbor. This value is overridden by
	// any more specific configuration value.
	Enabled bool `mapstructure:"enabled" json:"enabled,omitempty"`
}

// struct for container bgp-mp:config.
// Configuration parameters relating to multipath.
type UseMultiplePathsConfig struct {
	// original -> bgp-mp:enabled
	// bgp-mp:enabled's original type is boolean.
	// Whether the use of multiple paths for the same NLRI is
	// enabled for the neighbor. This value is overridden by
	// any more specific configuration value.
	Enabled bool `mapstructure:"enabled" json:"enabled,omitempty"`
}

func (lhs *UseMultiplePathsConfig) Equal(rhs *UseMultiplePathsConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Enabled != rhs.Enabled {
		return false
	}
	return true
}

// struct for container bgp-mp:use-multiple-paths.
// Parameters related to the use of multiple paths for the
// same NLRI.
type UseMultiplePaths struct {
	// original -> bgp-mp:use-multiple-paths-config
	// Configuration parameters relating to multipath.
	Config UseMultiplePathsConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp-mp:use-multiple-paths-state
	// State parameters relating to multipath.
	State UseMultiplePathsState `mapstructure:"state" json:"state,omitempty"`
	// original -> bgp-mp:ebgp
	// Multipath parameters for eBGP.
	Ebgp Ebgp `mapstructure:"ebgp" json:"ebgp,omitempty"`
	// original -> bgp-mp:ibgp
	// Multipath parameters for iBGP.
	Ibgp Ibgp `mapstructure:"ibgp" json:"ibgp,omitempty"`
}

func (lhs *UseMultiplePaths) Equal(rhs *UseMultiplePaths) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	if !lhs.Ebgp.Equal(&(rhs.Ebgp)) {
		return false
	}
	if !lhs.Ibgp.Equal(&(rhs.Ibgp)) {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information relating to the default route distance.
type DefaultRouteDistanceState struct {
	// original -> bgp:external-route-distance
	// Administrative distance for routes learned from external
	// BGP (eBGP).
	ExternalRouteDistance uint8 `mapstructure:"external-route-distance" json:"external-route-distance,omitempty"`
	// original -> bgp:internal-route-distance
	// Administrative distance for routes learned from internal
	// BGP (iBGP).
	InternalRouteDistance uint8 `mapstructure:"internal-route-distance" json:"internal-route-distance,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters relating to the default route
// distance.
type DefaultRouteDistanceConfig struct {
	// original -> bgp:external-route-distance
	// Administrative distance for routes learned from external
	// BGP (eBGP).
	ExternalRouteDistance uint8 `mapstructure:"external-route-distance" json:"external-route-distance,omitempty"`
	// original -> bgp:internal-route-distance
	// Administrative distance for routes learned from internal
	// BGP (iBGP).
	InternalRouteDistance uint8 `mapstructure:"internal-route-distance" json:"internal-route-distance,omitempty"`
}

func (lhs *DefaultRouteDistanceConfig) Equal(rhs *DefaultRouteDistanceConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.ExternalRouteDistance != rhs.ExternalRouteDistance {
		return false
	}
	if lhs.InternalRouteDistance != rhs.InternalRouteDistance {
		return false
	}
	return true
}

// struct for container bgp:default-route-distance.
// Administrative distance (or preference) assigned to
// routes received from different sources
// (external, internal, and local).
type DefaultRouteDistance struct {
	// original -> bgp:default-route-distance-config
	// Configuration parameters relating to the default route
	// distance.
	Config DefaultRouteDistanceConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:default-route-distance-state
	// State information relating to the default route distance.
	State DefaultRouteDistanceState `mapstructure:"state" json:"state,omitempty"`
}

func (lhs *DefaultRouteDistance) Equal(rhs *DefaultRouteDistance) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	return true
}

// struct for container bgp:state.
// State information relating to the global BGP router.
type GlobalState struct {
	// original -> bgp:as
	// bgp:as's original type is inet:as-number.
	// Local autonomous system number of the router.  Uses
	// the 32-bit as-number type from the model in RFC 6991.
	As uint32 `mapstructure:"as" json:"as,omitempty"`
	// original -> bgp:router-id
	// bgp:router-id's original type is inet:ipv4-address.
	// Router id of the router, expressed as an
	// 32-bit value, IPv4 address.
	RouterId string `mapstructure:"router-id" json:"router-id,omitempty"`
	// original -> bgp-op:total-paths
	// Total number of BGP paths within the context.
	TotalPaths uint32 `mapstructure:"total-paths" json:"total-paths,omitempty"`
	// original -> bgp-op:total-prefixes
	// .
	TotalPrefixes uint32 `mapstructure:"total-prefixes" json:"total-prefixes,omitempty"`
	// original -> gobgp:port
	Port int32 `mapstructure:"port" json:"port,omitempty"`
	// original -> gobgp:local-address
	LocalAddressList []string `mapstructure:"local-address-list" json:"local-address-list,omitempty"`
	Role             string   `mapstructure:"role" json:"role,omitempty"`
}

// struct for container bgp:config.
// Configuration parameters relating to the global BGP router.
type GlobalConfig struct {
	// original -> bgp:as
	// bgp:as's original type is inet:as-number.
	// Local autonomous system number of the router.  Uses
	// the 32-bit as-number type from the model in RFC 6991.
	As uint32 `mapstructure:"as" json:"as,omitempty"`
	// original -> bgp:router-id
	// bgp:router-id's original type is inet:ipv4-address.
	// Router id of the router, expressed as an
	// 32-bit value, IPv4 address.
	RouterId string `mapstructure:"router-id" json:"router-id,omitempty"`
	// original -> gobgp:port
	Port int32 `mapstructure:"port" json:"port,omitempty"`
	// original -> gobgp:local-address
	LocalAddressList []string `mapstructure:"local-address-list" json:"local-address-list,omitempty"`
	Role             string   `mapstructure:"role" json:"role,omitempty"`
}

func (lhs *GlobalConfig) Equal(rhs *GlobalConfig) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.As != rhs.As {
		return false
	}
	if lhs.RouterId != rhs.RouterId {
		return false
	}
	if lhs.Port != rhs.Port {
		return false
	}
	if len(lhs.LocalAddressList) != len(rhs.LocalAddressList) {
		return false
	}
	for idx, l := range lhs.LocalAddressList {
		if l != rhs.LocalAddressList[idx] {
			return false
		}
	}
	if lhs.Role != rhs.Role {
		return false
	}
	return true
}

// struct for container bgp:global.
// Global configuration for the BGP router.
type Global struct {
	// original -> bgp:global-config
	// Configuration parameters relating to the global BGP router.
	Config GlobalConfig `mapstructure:"config" json:"config,omitempty"`
	// original -> bgp:global-state
	// State information relating to the global BGP router.
	State GlobalState `mapstructure:"state" json:"state,omitempty"`
	// original -> bgp:default-route-distance
	// Administrative distance (or preference) assigned to
	// routes received from different sources
	// (external, internal, and local).
	DefaultRouteDistance DefaultRouteDistance `mapstructure:"default-route-distance" json:"default-route-distance,omitempty"`
	// original -> bgp-mp:use-multiple-paths
	// Parameters related to the use of multiple paths for the
	// same NLRI.
	UseMultiplePaths UseMultiplePaths `mapstructure:"use-multiple-paths" json:"use-multiple-paths,omitempty"`
	// original -> bgp:afi-safis
	// Address family specific configuration.
	AfiSafis []AfiSafi `mapstructure:"afi-safis" json:"afi-safis,omitempty"`
}

func (lhs *Global) Equal(rhs *Global) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Config.Equal(&(rhs.Config)) {
		return false
	}
	if !lhs.DefaultRouteDistance.Equal(&(rhs.DefaultRouteDistance)) {
		return false
	}
	if !lhs.UseMultiplePaths.Equal(&(rhs.UseMultiplePaths)) {
		return false
	}
	if len(lhs.AfiSafis) != len(rhs.AfiSafis) {
		return false
	}
	{
		lmap := make(map[string]*AfiSafi)
		for i, l := range lhs.AfiSafis {
			lmap[mapkey(i, string(l.Config.AfiSafiName))] = &lhs.AfiSafis[i]
		}
		for i, r := range rhs.AfiSafis {
			if l, y := lmap[mapkey(i, string(r.Config.AfiSafiName))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	return true
}

// struct for container bgp:bgp.
// Top-level configuration and state for the BGP router.
type Bgp struct {
	// original -> bgp:global
	// Global configuration for the BGP router.
	Global Global `mapstructure:"global" json:"global,omitempty"`
	// original -> bgp:neighbors
	// Configuration for BGP neighbors.
	Peers []Peer `mapstructure:"peers" json:"peers,omitempty"`
}

func (lhs *Bgp) Equal(rhs *Bgp) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Global.Equal(&(rhs.Global)) {
		return false
	}
	if len(lhs.Peers) != len(rhs.Peers) {
		return false
	}
	{
		lmap := make(map[string]*Peer)
		for i, l := range lhs.Peers {
			lmap[mapkey(i, string(l.Config.PeerAddress))] = &lhs.Peers[i]
		}
		for i, r := range rhs.Peers {
			if l, y := lmap[mapkey(i, string(r.Config.PeerAddress))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	return true
}
